
/*
 * Copyright (C) Igor Sysoev
 * Copyright (C) Nginx, Inc.
 */


#include <ngx_config.h>
#include <ngx_core.h>
#include <ngx_event.h>
#include <ngx_channel.h>


static void ngx_start_worker_processes(ngx_cycle_t *cycle, ngx_int_t n,
    ngx_int_t type);
static void ngx_start_cache_manager_processes(ngx_cycle_t *cycle,
    ngx_uint_t respawn);
static void ngx_pass_open_channel(ngx_cycle_t *cycle, ngx_channel_t *ch);
static void ngx_signal_worker_processes(ngx_cycle_t *cycle, int signo);
static ngx_uint_t ngx_reap_children(ngx_cycle_t *cycle);
static void ngx_master_process_exit(ngx_cycle_t *cycle);
static void ngx_worker_process_cycle(ngx_cycle_t *cycle, void *data);
static void ngx_worker_process_init(ngx_cycle_t *cycle, ngx_int_t worker);
static void ngx_worker_process_exit(ngx_cycle_t *cycle);
static void ngx_channel_handler(ngx_event_t *ev);
static void ngx_cache_manager_process_cycle(ngx_cycle_t *cycle, void *data);
static void ngx_cache_manager_process_handler(ngx_event_t *ev);
static void ngx_cache_loader_process_handler(ngx_event_t *ev);

//????????¶Ã??????????ngx_is_init_cycle???????reload???????????????nginx?????ngx_process == NGX_PROCESS_MASTER
ngx_uint_t    ngx_process;//????????????0???????NGX_PROCESS_SINGLE
ngx_uint_t    ngx_worker;
ngx_pid_t     ngx_pid;//ngx_pid = ngx_getpid(); ???????????????pid????master???master??pid

/*
??Linux?ßµ???????????????????Nginx?????????????????????????????????????????????????????????????????Nginx?????????
/usr/local/nginx/?ßµ???????????°§???/usr/local/nginc/sbin/nginx?????????°§???/usr/local/nginx/conf/nginx.conf???????
??configure??????????????????????????????????????????????????????????????ß÷????????????????????
????????Å£??????ùI?????®¿?

??1???????????

??????Nginx????????????ª«

/usr/local/nginx/sbin/nginx

????????????°§??????????????/usr/local/nginx/conf/nginx.conf??

?????????????????nginx.conf???????°§???????????configure???????????--conf-path=PATH?????nginx.conf??????¶Ã?1.5.1?????

??2?????????????????????????

???-c???????????????????ª«

/usr/local/nginx/sbin/nginx -c /tmp/nginx.conf

?????????-c???????????nginx.conf?????????????Nginx??

??3???????????????????????

???-p???????Nginx???????????ª«

/usr/local/nginx/sbin/nginx -p /usr/local/nginx/

??4??????????????????????????

???????-g???????????ßª???????????????????????ßπ?????ª«

/usr/local/nginx/sbin/nginx -g "pid /var/nginx/test.pid;"

??????????????¶∆????pid???ß’??/var/nginx/test.pid?ß≥?

-g?????????????????????????????????°§?????nginx.conf?ß÷????????????????????????????????????????????????????????pid logs/nginx.pid??
??????????????nginx.conf?ß÷??

?????????????????-g?????????Nginx?????????????????????????-g?????????????????????????????????¶±????Ì‡??????Nginx????
????????????????

/usr/local/nginx/sbin/nginx -g "pid /var/nginx/test.pid;" -s stop

?????????-g "pid /var/nginx/test.pid;"??????????pid??????????????????????????

??5?????????????????ß’???

???????Nginx???????????-t?????????????????????ß’??????ª«

/usr/local/nginx/sbin/nginx -t

??ßﬂ???????????????????

??6????????????¶¬???????

?????????????????-q???????????error?????????????????????????ª«

/usr/local/nginx/sbin/nginx -t -q

??7??????∑⁄???

???-v???????Nginx??∑⁄????????ª«

/usr/local/nginx/sbin/nginx -v

??8??????????¶≈????

???-V??????????????Nginx??∑⁄??????????????????????¶≈????????GCC????????∑⁄??????????∑⁄?????configure????????????ª«

/usr/local/nginx/sbin/nginx -V

??9?????????????

???-s stop?????????Nginx????-s????????????Nginx?????????????ß÷?Nginx?????????????Nginx???????nginx.pid????ß÷??master????????ID??
?????????ß÷?master???????TERM????????????Nginx???????ª«

/usr/local/nginx/sbin/nginx -s stop

????????????kill?????????nginx master???????TERM????INT????ßπ?????????????Ì‡?????ps????????nginx master?????ID??

:ahf5wapi001:root > ps -ef | grep nginx

root     10800     1  0 02:27 ?        00:00:00 nginx: master process ./nginx

root     10801 10800  0 02:27 ?        00:00:00 nginx: worker process

????????????kill??????????????

kill -s SIGTERM 10800

?????

kill -s SIGINT 10800

?????????????ßπ???????/usr/local/nginx/sbin/nginx -s stop???????????

??10?????????????????

??????Nginx?????????????????????????????????????????????-s quit???????????????ª«

/usr/local/nginx/sbin/nginx -s quit

?????????????Nginx?????????????????????????????worker??????master???????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????

??????????????????????????QUIT????master??????????????ßπ???????-s quit???????????????ª«

kill -s SIGQUIT <nginx master pid>

????????????????????worker????????????????????????WINCH??????????????ª«

kill -s SIGWINCH <nginx worker pid>

??11????????ß÷?Nginx???????????ßπ

???-s reload??????????????ß÷?Nginx???????????nginx.conf????????ª«

/usr/local/nginx/sbin/nginx -s reload

??????Nginx???????????????????????????????????????????????????????????Nginx??????????????????-s?????????
?????????kill??????HUP????????????ßπ????

kill -s SIGHUP <nginx master pid>

??12???????????

???-s reopen?????????????????????????????????????????????????????????ßﬂ??ß“??????????????????????????????
????????????????????????????ª«

/usr/local/nginx/sbin/nginx -s reopen

????????????kill??????USR1???ßπ???????

kill -s SIGUSR1 <nginx master pid>

??13?????????Nginx

??Nginx?????????????∑⁄?????????????????????Nginx?ùI???????????????????????????????Nginx??????????????????°„∑⁄???????????

???????????????—s

1???????????ß÷??∑⁄Nginx??????????????master???????USR2????????????ª«

kill -s SIGUSR2 <nginx master pid>

??????????ß÷?Nginx??pid????????????¡L/usr/local/nginx/logs/nginx.pid???????/usr/local/nginx/logs/nginx.pid.oldbin?????????Nginx???ß·????????????

2???????°„∑⁄??Nginx??????????????????????????????????????????ps?????????????∑⁄??Nginx???????ß≥?

3?????kill???????∑⁄??master???????SIGQUIT????????????????????∑⁄??Nginx?????????°„∑⁄??Nginx???????ßµ???????????????

??14??????????ß—???

???-h????-???????????????????????ß”?????

*/
sig_atomic_t  ngx_reap;
sig_atomic_t  ngx_sigio;
sig_atomic_t  ngx_sigalrm;
sig_atomic_t  ngx_terminate; //???????TERM??????ngx_terminate???¶À?????1???????????worker????????????????
sig_atomic_t  ngx_quit; //???????QUIT??????ngx_quit???¶À?????1???????????worker??????????????????
sig_atomic_t  ngx_debug_quit;
ngx_uint_t    ngx_exiting; //ngx_exiting???¶À????ngx_worker_process_cycle????????????????¶À???
sig_atomic_t  ngx_reconfigure;//nginx -s reload?????????
sig_atomic_t  ngx_reopen; //???????USRI??????ngx_reopen???¶À?????1???????????Nginx????????????????ß›??????????

sig_atomic_t  ngx_change_binary; //??????????°„∑⁄??Nginx??????????
ngx_pid_t     ngx_new_binary;//??????????ùI???????????execve??????????? ???????ngx_change_binary??????????
ngx_uint_t    ngx_inherited;
ngx_uint_t    ngx_daemonized;

sig_atomic_t  ngx_noaccept;
ngx_uint_t    ngx_noaccepting;
ngx_uint_t    ngx_restart;


static u_char  master_process[] = "master process";

/*
??Nginx?ßµ??????????proxy(fastcgi) cache?????master process???????????????????????????????????(???????????????????)????????
????????????â^???????????????????¸v?ó®??????????????????????????????????????????????????????????
??????????(??Nginx?⁄Ö????????60??)??????????

???????????????????ngx_process_events_and_timers()?????ßµ??????ngx_event_expire_timers()??Nginx??ngx_event_timer_rbtree(?????)??
?ÀÆ????ß÷???????????????ß÷???????????????????????????????????????????????ß⁄?????????????????handler??????
?????handler?????ngx_cache_manager_process_handler??ngx_cache_loader_process_handler

??????manger ?? loader?????????????ngx_cache_manager_process_handler??ngx_cache_loader_process_handler?????????????manager???
???????????0????loader??60000????????????manager??nginx????????????????????loader????nginx??????1?????????????
*/
static ngx_cache_manager_ctx_t  ngx_cache_manager_ctx = {
    ngx_cache_manager_process_handler, "cache manager process", 0
};
static ngx_cache_manager_ctx_t  ngx_cache_loader_ctx = {
    ngx_cache_loader_process_handler, "cache loader process", 60000  //?????????60000m?????ngx_cache_loader_process_handler,??ngx_cache_manager_process_cycle???????????
};


static ngx_cycle_t      ngx_exit_cycle;
static ngx_log_t        ngx_exit_log;
static ngx_open_file_t  ngx_exit_log_file;
/*

ngx_master_process_cycle ?? ?? ngx_start_worker_processes????????????????ngx_start_worker_processes ?? ?? ngx_worker_process_cycle
?????????????????????ßÿ????????????????????????????????????????????????ngx_worker_process_cycle 
???????????????? ngx_process_events_and_timers ?? ?? ?? ?? ?? ?? ngx_process_events?????????
??????????????????ngx_posted_events ?? ?? ?? ?? ?? ?? ngx_event_thread_process_posted?ß’????????
*/
/*
master???????????????????????????????????ßµ???????????worker?????
???????????????????????????????????????????????ßπ?????
*/

//???????????????????????ngx_master_process_cycle??????????????? 
void
ngx_master_process_cycle(ngx_cycle_t *cycle)
{
    char              *title;
    u_char            *p;
    size_t             size;
    ngx_int_t          i;
    ngx_uint_t         n, sigio;
    sigset_t           set;
    struct itimerval   itv;
    ngx_uint_t         live;
    ngx_msec_t         delay;
    ngx_listening_t   *ls;
    ngx_core_conf_t   *ccf;


    sigemptyset(&set);
    sigaddset(&set, SIGCHLD);
    sigaddset(&set, SIGALRM);
    sigaddset(&set, SIGIO);
    sigaddset(&set, SIGINT);
    sigaddset(&set, ngx_signal_value(NGX_RECONFIGURE_SIGNAL));
    sigaddset(&set, ngx_signal_value(NGX_REOPEN_SIGNAL));
    sigaddset(&set, ngx_signal_value(NGX_NOACCEPT_SIGNAL));
    sigaddset(&set, ngx_signal_value(NGX_TERMINATE_SIGNAL));
    sigaddset(&set, ngx_signal_value(NGX_SHUTDOWN_SIGNAL));
    sigaddset(&set, ngx_signal_value(NGX_CHANGEBIN_SIGNAL));

    /*
     ???????????????????(signal mask)??????????????????????¶À???????????¶À?????????????
     ???¶À??ß÷???¶À?1??????????ß÷??????????????????????????????????¶±??????????ß÷?????ß”??????????????????
     
     ????????????????????????????????CTRL_C??????????????????????????????????????????????CTRL_C?????????????????
     ???????SIGINT ????????????????????????????do_exit()?????????????ß≥????????ßª??®Æ???????CTRL_C??????????????????
     ?SIGINT???????????????????????????®Æ????ß÷????????????????????ßÿ?CTRL_C?????????????????????????????????????CTRL_C
     ?????????????????????????????????????????????SIGINT???????????????????????????????????????????????????
     ????????????????????????????????????????????????????????????????ßﬂ??????????????¶≈?????¶Õ?????¶±???????????
     ????????????????????????????????????????????????????????????????
     
     ??¶Õ????, ???????????????, ??????????????????,
     ??????¶ ?, ??????????, ?????
     */ // ??????ßª????????????????sigpending???®∞??????????ßª???
     
    if (sigprocmask(SIG_BLOCK, &set, NULL) == -1) {   //?¶œ??????sigsuspend     
    //?????????ß€??????¶œ?:http://blog.chinaunix.net/uid-20011314-id-1987626.html
        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                      "sigprocmask() failed");
    }

    sigemptyset(&set); 


    size = sizeof(master_process);

    for (i = 0; i < ngx_argc; i++) {
        size += ngx_strlen(ngx_argv[i]) + 1;
    }

    title = ngx_pnalloc(cycle->pool, size);
    if (title == NULL) {
        /* fatal */
        exit(2);
    }

    /* ??master process + ??????????????????? */
    p = ngx_cpymem(title, master_process, sizeof(master_process) - 1);
    for (i = 0; i < ngx_argc; i++) {
        *p++ = ' ';
        p = ngx_cpystrn(p, (u_char *) ngx_argv[i], size);
    }

    ngx_setproctitle(title); //?????????title

    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);

    ngx_start_worker_processes(cycle, ccf->worker_processes,
                               NGX_PROCESS_RESPAWN); //????worker????
    ngx_start_cache_manager_processes(cycle, 0); //????cache manager?? cache loader????

    ngx_new_binary = 0;
    delay = 0;
    sigio = 0;
    live = 1;

/*
    ngx_signal_handler??????????????????????ngx_reap. ngx_quit. ngx_terminate.
ngx_reconfigure. ngx_reopen. ngx_change_binary. ngx_noaccept??ßª???¶À??????8-40
??8-4?????ßﬂ??????????Nginx????????
??????????????????????????????????????????????????????????????????????????????????????????????????
??    ??  ??    ??  ????????ß÷??????¶À????  ??    ????                                        ??
???????????????????????????????????????????????????????????????????????????????????????????????
??  QUIT        ??    ngx_quit                  ??  ???????????????                            ??
???????????????????????????????????????????????????????????????????????????????????????????????
??  TERM????INT ??ngx_terminate                 ??  ?????????????                              ??
???????????????????????????????????????????????????????????????????????????????????????????????
??  USR1        ??    ngx reopen                ??  ?????????ß÷????????                      ??
???????????????????????????????????????????????????????????????????????????????????????????????
??              ??                              ??  ??????????????????????????????????  ??
??  WINCH       ??ngx_noaccept                  ??                                                ??
??              ??                              ?????ß÷?????????QUIT?????                      ??
???????????????????????????????????????????????????????????????????????????????????????????????
??  USR2        ??ngx_change_binary             ??  ??????????°„∑⁄??Nginx????                   ??
???????????????????????????????????????????????????????????????????????????????????????????????
??  HUP         ??ngx_reconfigure               ??  ?????????????????????ÇC????ßπ            ??
???????????????????????????????????????????????????????????????????????????????????????????????
??              ??                              ??  ????????????????????????????ß÷???????  ??
??  CHLD        ??    ngx_reap                  ???????ngx_reap_children?????????????           ??
??????????????????????????????????????????????????????????????????????????????????????????????????
    ??8-4?ß‘???master?????????ß÷?7???????¶À???????????????????????¶À?
?????????????????master????????????????¶À??????????????

??????????????8?????¶À??ngx_reap??ngx_terminate??ngx_quit??ngx_reconfigure??ngx_restart??ngx_reopen??ngx_change_binary??
ngx_noaccept????????ß”??????????????????ßµ????????????????????????????????????????????????ßµ???
*/
    for ( ;; ) {
        /*
        delay????????????????????????????????SIGINT????????????????????????????????????????????????
        ???????????????????????????????????????????sigkill?????????(??????),??????????
          */
        if (delay) 
        {
            if (ngx_sigalrm) {
                sigio = 0;
                delay *= 2;
                ngx_sigalrm = 0;
            }

            ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
                           "termination cycle: %d", delay);
            //delay = 2000;
            itv.it_interval.tv_sec = 0;
            itv.it_interval.tv_usec = 0;
            itv.it_value.tv_sec = delay / 1000;
            itv.it_value.tv_usec = (delay % 1000 ) * 1000;

            /*
            setitimer(int which, const struct itimerval *value, struct itimerval *ovalue)); 
            setitimer()??alarm??????????3????????????? 
            
            ITIMER_REAL?? ?⁄Ö????????????????????????????SIGALRM???????????
            ITIMER_VIRTUAL ?⁄Ö???????????????????????????????SIGVTALRM???????????
            ITIMER_PROF ?⁄Ö??????????????????????????????????????????????????ITIMER_VIRTUAL???????????
            
            */ //?????????????????????????????SIGALRM???,?????????????????ngx_sigalrm?1??????delay??????????
            if (setitimer(ITIMER_REAL, &itv, NULL) == -1) { //???itv????????SIGALRM???
                ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                              "setitimer() failed");
            }
        }

        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, cycle->log, 0, "sigsuspend");

        /*
          sigsuspend(const sigset_t *mask))??????????????????, ?????mask?ùI????????????, ???????????ßµ??????????????
          sigsuspend ??????????????????????????????????????????????ß≥???????????????-1??????errno?????EINTR??

         
          ???sigsuspend?????????????????4?????—s
          (1) ???????mask????????????
          (2) ?????????????mask??
          (3) ?????????????????????????
          (4) ?????????????????sigsuspend?????
          
          */ 
        /*
        ?????????,???sigprocmask????????sigemptyset(&set);????????????????????????????????????????æN????  ngx_reap ngx_terminate?????
        ???????(2)????????????????????????????ßÿ???????????????????????????????mask(?????????sigprocmask?????????)
        ?????????????????ß”???????????????????????while()?????????sigsuspend?????????????ßÿ???????????????????ßÿ??????
        */
        //nginx sigsuspend???????¶œ?http://weakyon.com/2015/05/14/learning-of-sigsuspend.html
        sigsuspend(&set); //????????????????ngx_init_signals???ngx_signal_handler?ß÷?SIGALRM???????????????????????®≤???????????

        ngx_time_update();

        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
                       "wake up, sigio %i", sigio);

        if (ngx_reap) { //????????????????????????????ngx_signal_handler
            ngx_reap = 0;
            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, cycle->log, 0, "reap children");

            ///??????õ®????????????(?ß÷?worker?????????????????????????worker )???????????????????????0. 
            live = ngx_reap_children(cycle); // ????????????????????????????ß÷????????????ngx_reap_children?????????????
        }

        //?????ß’??????????????????ngx_terminate????ngx_quit??????master????? 
        if (!live && (ngx_terminate || ngx_quit)) {
            ngx_master_process_exit(cycle);
        }

        /*
         ???ngx_terminate???¶À?l?????????????????????TERM???????????????????????????????????1?????????????????????????
         */
        if (ngx_terminate) { //?????sigint????
            if (delay == 0) {///?????????
                delay = 50;
            }

            if (sigio) {
                sigio--;
                continue;
            }

            sigio = ccf->worker_processes + 2 /* cache processes */;

            if (delay > 1000) { //????????????????worker  
                ngx_signal_worker_processes(cycle, SIGKILL);
            } else { //??????sigint??worker???????????  
                ngx_signal_worker_processes(cycle,
                                       ngx_signal_value(NGX_TERMINATE_SIGNAL));
            }

            continue;
        }

        /*
          ????'ngx_quit?1???????????????ß÷???????????????????????1????????master??????????????????
          */
        if (ngx_quit) {///???quit???? 
            
            //?????worker quit???  
            ngx_signal_worker_processes(cycle,
                                        ngx_signal_value(NGX_SHUTDOWN_SIGNAL));

            ls = cycle->listening.elts;
            for (n = 0; n < cycle->listening.nelts; n++) {
                if (ngx_close_socket(ls[n].fd) == -1) {
                    ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_socket_errno,
                                  ngx_close_socket_n " %V failed",
                                  &ls[n].addr_text);
                }
            }
            cycle->listening.nelts = 0;

            continue;
        }

        //??????reconfig?????  
        /*
         ???ngx_reconfigure???¶À?0??????????13?????ngx_restart???¶À?????ngx_reconfigure?l????????????????????????
         Nginx????????????worker?????????????????????????????????????????ngx_cycle_t???»…?????????????????????
         ?????????worker???????????worker??????????ßﬂ??????ngx_init_cycle????????????ngx_cycle_t???â^
          */
        if (ngx_reconfigure) { //?????????????????????ÇC????ßπ 
            ngx_reconfigure = 0;

            if (ngx_new_binary) { //?ßÿ??????????ùI?????????????????(???????????????master)??????????????ßµ??????????????config??  
                ngx_start_worker_processes(cycle, ccf->worker_processes,
                                           NGX_PROCESS_RESPAWN);
                ngx_start_cache_manager_processes(cycle, 0);
                ngx_noaccepting = 0;

                continue;
            }

            ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, "reconfiguring");

            cycle = ngx_init_cycle(cycle); //????????config???????????????worker  
            if (cycle == NULL) {
                cycle = (ngx_cycle_t *) ngx_cycle;
                continue;
            }

            ngx_cycle = cycle;
            ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx,
                                                   ngx_core_module);

            //????ngx_start_worker_processes?????????????worker???????ßªworker??????????ngx_cycle_t?????â^
            ngx_start_worker_processes(cycle, ccf->worker_processes,
                                       NGX_PROCESS_JUST_RESPAWN);
                                       
            //????ngx_start_cache_ _manager_processes??????????????????????????????????cache manage????cache loader?????
            //???????????????®≤??????????????????????live???¶À???1
            ngx_start_cache_manager_processes(cycle, 1);

            /* allow new processes to start */
            ngx_msleep(100);

            live = 1;

            //???????????????????????????????QUIT????????????????????????????
            ngx_signal_worker_processes(cycle,
                                        ngx_signal_value(NGX_SHUTDOWN_SIGNAL));
        }

        if (ngx_restart) {
            ngx_restart = 0;
            ngx_start_worker_processes(cycle, ccf->worker_processes,
                                       NGX_PROCESS_RESPAWN);
            ngx_start_cache_manager_processes(cycle, 0);
            live = 1;
        }

        /*
         ???-s reopen?????????????????????????????????????????????????????????ßﬂ??ß“??????????????????????????????
    ????????????????????????????????????kill??????USR1???ßπ???????
        */
        if (ngx_reopen) {
            /*
                ???ngx_reopen?1???????ngx_reopen_files????????????????????ngx_reopen???¶À???0??
                ??????????????USRI?????????????????????????????
               */
            ngx_reopen = 0;
            ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, "reopening logs");
            ngx_reopen_files(cycle, ccf->user);
            ngx_signal_worker_processes(cycle,
                                        ngx_signal_value(NGX_REOPEN_SIGNAL));
        }

        /*
         ???ngx_change_binary???¶À?????ngx_change_binary?1????????????????Nginx???????????ngx_exec_new_binary???????????
         ?????????°„∑⁄??Nginx???? ????ngx_change_binary???¶À???0??
          */
        if (ngx_change_binary) { //??????????°„∑⁄??Nginx????
            ngx_change_binary = 0;
            ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, "changing binary");
            ngx_new_binary = ngx_exec_new_binary(cycle, ngx_argv);///??????????ùI???????????execve??????????? 
        }

        
        ///???????accept?????????????worker???(??????????????master????????).??  
        /*
          ???ngx_noaccept???¶À?????ngx_noaccept?0?????????1???????????????????ngx_noacicept?1?????????ß÷?????????QUIT????
          ?????????????????????ngx_noaccept???0??????ngx_noaccepting???1???????????????????????
          */
        if (ngx_noaccept) {//?????????????????????????????????????ß÷?????????QUIT?????
            ngx_noaccept = 0;
            ngx_noaccepting = 1;

            //??worker????????  
            ngx_signal_worker_processes(cycle,
                                        ngx_signal_value(NGX_SHUTDOWN_SIGNAL));
        }
    }
}

/*
???hginx.conf??????????????????????????????ngx_single_process_cycle??????????????????
*/
void
ngx_single_process_cycle(ngx_cycle_t *cycle)
{
    ngx_uint_t  i;

    if (ngx_set_environment(cycle, NULL) == NULL) {
        /* fatal */
        exit(2);
    }

    for (i = 0; ngx_modules[i]; i++) {
        if (ngx_modules[i]->init_process) {
            if (ngx_modules[i]->init_process(cycle) == NGX_ERROR) {
                /* fatal */
                exit(2);
            }
        }
    }

    for ( ;; ) {
        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, cycle->log, 0, "worker cycle");

        ngx_process_events_and_timers(cycle);

        if (ngx_terminate || ngx_quit) {

            for (i = 0; ngx_modules[i]; i++) {
                if (ngx_modules[i]->exit_process) {
                    ngx_modules[i]->exit_process(cycle);
                }
            }

            ngx_master_process_exit(cycle);
        }

        if (ngx_reconfigure) {
            ngx_reconfigure = 0;
            ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, "reconfiguring");

            cycle = ngx_init_cycle(cycle);
            if (cycle == NULL) {
                cycle = (ngx_cycle_t *) ngx_cycle;
                continue;
            }

            ngx_cycle = cycle;
        }

        if (ngx_reopen) {
            ngx_reopen = 0;
            ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, "reopening logs");
            ngx_reopen_files(cycle, (ngx_uid_t) -1);
        }
    }
}

static void
ngx_start_worker_processes(ngx_cycle_t *cycle, ngx_int_t n, ngx_int_t type)
{
    ngx_int_t      i;
    ngx_channel_t  ch;

    ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, "start worker processes");

    ngx_memzero(&ch, sizeof(ngx_channel_t));

    //?????????worker?????????????????   
    ch.command = NGX_CMD_OPEN_CHANNEL;

    /*
    ??master????????????????worker????????????????ßª???????????????8-2?ß÷?ngx_start_worker_processes????????
    */
    for (i = 0; i < n; i++) { //n?nginx.conf worker_processes????????????
/*
                                 |----------(ngx_worker_process_cycle->ngx_worker_process_init)
    ngx_start_worker_processes---| ngx_processes[]??????????????
                                 |----------ngx_pass_open_channel
*/
        ngx_spawn_process(cycle, ngx_worker_process_cycle,
                          (void *) (intptr_t) i, "worker process", type);

        //???????????worker????????????worker?????????????   
        ch.pid = ngx_processes[ngx_process_slot].pid;
        ch.slot = ngx_process_slot;
        ch.fd = ngx_processes[ngx_process_slot].channel[0]; //ngx_spawn_process?ß⁄??

        /*  
           ???????????????????????????socketpair?????????????????????socket  
           channel[]?????????ß⁄???????channel[0]?ß’???channel[1]?????  

            
           ????????socket[0],???????socket[1]?????????sockets[1]?ßÿ?ß’????????sockets[0]?ßÿ?ß’????????????????¶œ?http://www.xuebuyuan.com/1691574.html
           ????????????channel???????????????????????????????
         */
        ngx_pass_open_channel(cycle, &ch); 
    }
}

/*
??Nginx?ßµ??????????proxy(fastcgi) cache?????master process???????????????????????????????????(???????????????????)????????
????????????â^???????????????????¸v?ó®??????????????????????????????????????????????????????????
??????????(??Nginx?⁄Ö????????60??)??????????

???????????????????ngx_process_events_and_timers()?????ßµ??????ngx_event_expire_timers()??Nginx??ngx_event_timer_rbtree(?????)??
?ÀÆ????ß÷???????????????ß÷???????????????????????????????????????????????ß⁄?????????????????handler??????
?????handler?????ngx_cache_manager_process_handler??ngx_cache_loader_process_handler
*/
static void
ngx_start_cache_manager_processes(ngx_cycle_t *cycle, ngx_uint_t respawn)
{
    ngx_uint_t       i, manager, loader;
    ngx_path_t     **path;
    ngx_channel_t    ch;

    manager = 0;
    loader = 0;

    path = ngx_cycle->paths.elts;
    for (i = 0; i < ngx_cycle->paths.nelts; i++) {

        if (path[i]->manager) {
            manager = 1;
        }

        if (path[i]->loader) {
            loader = 1;
        }
    }

/*
??????????ßµ???master???????????????????????????????????cachemanage??????????????ngx_cycle_t?ß’õ•°§??????????
pathes??????????°§????manage???¶À???????????????cache manage????????????¶ ?1??°§????manage???¶À?1????????cache manage??????
*/
    if (manager == 0) { //??????????????????????1??????????????????÷Œ??????cache manage??load????
        return;
    }

    /*
    ??Nginx?ßµ??????????proxy(fastcgi) cache?????master process???????????????????????????????????(???????????????????)????????
    ????????????â^???????????????????¸v?ó®??????????????????????????????????????????????????????????
    ??????????(??Nginx?⁄Ö????????60??)??????????
    
    ???????????????????ngx_process_events_and_timers()?????ßµ??????ngx_event_expire_timers()??Nginx??ngx_event_timer_rbtree(?????)??
    ?ÀÆ????ß÷???????????????ß÷???????????????????????????????????????????????ß⁄?????????????????handler??????
    ?????handler?????ngx_cache_manager_process_handler??ngx_cache_loader_process_handler
    */
    ngx_spawn_process(cycle, ngx_cache_manager_process_cycle,
                      &ngx_cache_manager_ctx, "cache manager process",
                      respawn ? NGX_PROCESS_JUST_RESPAWN : NGX_PROCESS_RESPAWN);

    ngx_memzero(&ch, sizeof(ngx_channel_t));

    ch.command = NGX_CMD_OPEN_CHANNEL;
    ch.pid = ngx_processes[ngx_process_slot].pid;
    ch.slot = ngx_process_slot;
    ch.fd = ngx_processes[ngx_process_slot].channel[0];

    ngx_pass_open_channel(cycle, &ch);

    /*
    ??????¶ ?1??°§????loader???¶À?1????????cache loader?????, ???????????????????
    */
    if (loader == 0) {
        return;
    }

    
    ngx_spawn_process(cycle, ngx_cache_manager_process_cycle,
                      &ngx_cache_loader_ctx, "cache loader process",
                      respawn ? NGX_PROCESS_JUST_SPAWN : NGX_PROCESS_NORESPAWN);

    ch.command = NGX_CMD_OPEN_CHANNEL;
    ch.pid = ngx_processes[ngx_process_slot].pid;
    ch.slot = ngx_process_slot;
    ch.fd = ngx_processes[ngx_process_slot].channel[0];

    ngx_pass_open_channel(cycle, &ch);
}

/*
????????????????????????????????ßµ???????õØ?????????????????õØ??????????channel????????????????????
?????õØ??????????????????????????? ?????????õØ?????????????????????????????????????????????
??channel,?????????????channel[0]?ßµ??????????????????
*/
/*
                                 |----------(ngx_worker_process_cycle->ngx_worker_process_init)
    ngx_start_worker_processes---| ngx_processes[]??????????????
                                 |----------ngx_pass_open_channel
*/
static void 
ngx_pass_open_channel(ngx_cycle_t *cycle, ngx_channel_t *ch)
{ //?®≤???????????????????????????????????????????????????????????ß€?????????????????????ch->fd?????ß÷?
    ngx_int_t  i;

    for (i = 0; i < ngx_last_process; i++) { /* ngx_last_process?????????????ngx_spawn_process()?ß“?????????????????? */  

        
        // ???????????worker????? || ???????????? || ?ÕË????socket?????????  
        //?????ngx_worker_process_init?ß÷?channel????????????
        if (i == ngx_process_slot
            || ngx_processes[i].pid == -1
            || ngx_processes[i].channel[0] == -1) //?????????????worker     
        {
            continue;
        } //

        ngx_log_debug6(NGX_LOG_DEBUG_CORE, cycle->log, 0,
                      "pass channel s:%d pid:%P fd:%d to s:%i pid:%P fd:%d",
                      ch->slot, ch->pid, ch->fd,
                      i, ngx_processes[i].pid,
                      ngx_processes[i].channel[0]);

        /* TODO: NGX_AGAIN */
        //???????????????worker   
        /* ??????????????????????worker??????????IPC????????? */  
        
        //?????ngx_worker_process_init?ß÷?channel????????????
        //?? ??????? channel[0]???????    
        
        //?????????????????????ßﬂ????channel[0]?? ???????????????????? 
        
        ngx_write_channel(ngx_processes[i].channel[0],
                          ch, sizeof(ngx_channel_t), cycle->log); //ch????????????ngx_processes[i].channel[0]????????????
    }
}

/*
NGX_PROCESS_JUST_RESPAWN??????????ngx_spawn_process()????worker?????????ngx_processes[s].just_spawn = 1??????????????worker????????
?????ßµ?
ngx_signal_worker_processes(cycle, ngx_signal_value(NGX_SHUTDOWN_SIGNAL));  
???????worker?????????®≤????????????????????????worker???????????????????????worker??????????????????worker?????
*/
static void     //ngx_reap_children??ngx_signal_worker_processes???
ngx_signal_worker_processes(ngx_cycle_t *cycle, int signo) //????????signo???
{
    ngx_int_t      i;
    ngx_err_t      err;
    ngx_channel_t  ch;

    ngx_memzero(&ch, sizeof(ngx_channel_t));

#if (NGX_BROKEN_SCM_RIGHTS)

    ch.command = 0;

#else

    switch (signo) {

    case ngx_signal_value(NGX_SHUTDOWN_SIGNAL):
        ch.command = NGX_CMD_QUIT;
        break;

    case ngx_signal_value(NGX_TERMINATE_SIGNAL):
        ch.command = NGX_CMD_TERMINATE;
        break;

    case ngx_signal_value(NGX_REOPEN_SIGNAL):
        ch.command = NGX_CMD_REOPEN;
        break;

    default:
        ch.command = 0;
    }

#endif

    ch.fd = -1;


    for (i = 0; i < ngx_last_process; i++) {

        ngx_log_debug7(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
                       "child: %d %P e:%d t:%d d:%d r:%d j:%d",
                       i,
                       ngx_processes[i].pid,
                       ngx_processes[i].exiting,
                       ngx_processes[i].exited,
                       ngx_processes[i].detached,
                       ngx_processes[i].respawn,
                       ngx_processes[i].just_spawn);

        if (ngx_processes[i].detached || ngx_processes[i].pid == -1) {
            continue;
        }

        if (ngx_processes[i].just_spawn) {
            ngx_processes[i].just_spawn = 0;
            continue;
        }

        if (ngx_processes[i].exiting
            && signo == ngx_signal_value(NGX_SHUTDOWN_SIGNAL))
        {
            continue;
        }

        if (ch.command) {
            if (ngx_write_channel(ngx_processes[i].channel[0],
                                  &ch, sizeof(ngx_channel_t), cycle->log)
                == NGX_OK)
            {
                if (signo != ngx_signal_value(NGX_REOPEN_SIGNAL)) {
                    ngx_processes[i].exiting = 1;
                }

                continue;
            }
        }

        ngx_log_debug2(NGX_LOG_DEBUG_CORE, cycle->log, 0,
                       "kill (%P, %d)", ngx_processes[i].pid, signo);

        if (kill(ngx_processes[i].pid, signo) == -1) { //?????????  
            err = ngx_errno;
            ngx_log_error(NGX_LOG_ALERT, cycle->log, err,
                          "kill(%P, %d) failed", ngx_processes[i].pid, signo);

            if (err == NGX_ESRCH) {
                ngx_processes[i].exited = 1;
                ngx_processes[i].exiting = 0;
                ngx_reap = 1;
            }

            continue;
        }

        if (signo != ngx_signal_value(NGX_REOPEN_SIGNAL)) {
            ngx_processes[i].exiting = 1;
        }
    }
}

///??????õ®????????????(?ß÷?worker?????????????????????????worker )???????????????????????0. 
static ngx_uint_t
ngx_reap_children(ngx_cycle_t *cycle) //ngx_reap_children??ngx_signal_worker_processes???
{
    ngx_int_t         i, n;
    ngx_uint_t        live;
    ngx_channel_t     ch;
    ngx_core_conf_t  *ccf;

    ngx_memzero(&ch, sizeof(ngx_channel_t));

    ch.command = NGX_CMD_CLOSE_CHANNEL;
    ch.fd = -1;

    live = 0;
    for (i = 0; i < ngx_last_process; i++) {

        ngx_log_debug7(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
                       "child: %d %P e:%d t:%d d:%d r:%d j:%d",
                       i,
                       ngx_processes[i].pid,
                       ngx_processes[i].exiting,
                       ngx_processes[i].exited,
                       ngx_processes[i].detached,
                       ngx_processes[i].respawn,
                       ngx_processes[i].just_spawn);

        if (ngx_processes[i].pid == -1) {
            continue;
        }

        if (ngx_processes[i].exited) {

            if (!ngx_processes[i].detached) {
                ngx_close_channel(ngx_processes[i].channel, cycle->log);

                ngx_processes[i].channel[0] = -1;
                ngx_processes[i].channel[1] = -1;

                ch.pid = ngx_processes[i].pid;
                ch.slot = i;

                for (n = 0; n < ngx_last_process; n++) {
                    if (ngx_processes[n].exited
                        || ngx_processes[n].pid == -1
                        || ngx_processes[n].channel[0] == -1)
                    {
                        continue;
                    }

                    ngx_log_debug3(NGX_LOG_DEBUG_CORE, cycle->log, 0,
                                   "pass close channel s:%i pid:%P to:%P",
                                   ch.slot, ch.pid, ngx_processes[n].pid);

                    /* TODO: NGX_AGAIN */

                    ngx_write_channel(ngx_processes[n].channel[0],
                                      &ch, sizeof(ngx_channel_t), cycle->log);
                }
            }

            if (ngx_processes[i].respawn
                && !ngx_processes[i].exiting
                && !ngx_terminate
                && !ngx_quit)
            {
                if (ngx_spawn_process(cycle, ngx_processes[i].proc,
                                      ngx_processes[i].data,
                                      ngx_processes[i].name, i)
                    == NGX_INVALID_PID)
                {
                    ngx_log_error(NGX_LOG_ALERT, cycle->log, 0,
                                  "could not respawn %s",
                                  ngx_processes[i].name);
                    continue;
                }


                ch.command = NGX_CMD_OPEN_CHANNEL;
                ch.pid = ngx_processes[ngx_process_slot].pid;
                ch.slot = ngx_process_slot;
                ch.fd = ngx_processes[ngx_process_slot].channel[0];

                ngx_pass_open_channel(cycle, &ch);

                live = 1;

                continue;
            }

            if (ngx_processes[i].pid == ngx_new_binary) {

                ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx,
                                                       ngx_core_module);

                if (ngx_rename_file((char *) ccf->oldpid.data,
                                    (char *) ccf->pid.data)
                    == NGX_FILE_ERROR)
                {
                    ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                                  ngx_rename_file_n " %s back to %s failed "
                                  "after the new binary process \"%s\" exited",
                                  ccf->oldpid.data, ccf->pid.data, ngx_argv[0]);
                }

                ngx_new_binary = 0;
                if (ngx_noaccepting) {
                    ngx_restart = 1;
                    ngx_noaccepting = 0;
                }
            }

            if (i == ngx_last_process - 1) {
                ngx_last_process--;

            } else {
                ngx_processes[i].pid = -1;
            }

        } else if (ngx_processes[i].exiting || !ngx_processes[i].detached) {
            live = 1;
        }
    }

    return live;
}


static void
ngx_master_process_exit(ngx_cycle_t *cycle)
{
    ngx_uint_t  i;

    ngx_delete_pidfile(cycle);

    ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, "exit");

    for (i = 0; ngx_modules[i]; i++) {
        if (ngx_modules[i]->exit_master) {
            ngx_modules[i]->exit_master(cycle);
        }
    }

    ngx_close_listening_sockets(cycle);

    /*
     * Copy ngx_cycle->log related data to the special static exit cycle,
     * log, and log file structures enough to allow a signal handler to log.
     * The handler may be called when standard ngx_cycle->log allocated from
     * ngx_cycle->pool is already destroyed.
     */


    ngx_exit_log = *ngx_log_get_file_log(ngx_cycle->log);

    ngx_exit_log_file.fd = ngx_exit_log.file->fd;
    ngx_exit_log.file = &ngx_exit_log_file;
    ngx_exit_log.next = NULL;
    ngx_exit_log.writer = NULL;

    ngx_exit_cycle.log = &ngx_exit_log;
    ngx_exit_cycle.files = ngx_cycle->files;
    ngx_exit_cycle.files_n = ngx_cycle->files_n;
    ngx_cycle = &ngx_exit_cycle;

    ngx_destroy_pool(cycle->pool);

    exit(0);
}

/*
                                 |----------(ngx_worker_process_cycle->ngx_worker_process_init)
    ngx_start_worker_processes---| ngx_processes[]??????????????
                                 |----------ngx_pass_open_channel
*/
//??Nginx???????????????????ngx_worker_process_cycle???????ßµ??????????????ÔÖ??????????????????????
static void
ngx_worker_process_cycle(ngx_cycle_t *cycle, void *data) //data???????????worker????
{
    ngx_int_t worker = (intptr_t) data; //worker???????????cpu??

    ngx_uint_t         i;
    ngx_connection_t  *c;

    ngx_process = NGX_PROCESS_WORKER;
    ngx_worker = worker;

    ngx_worker_process_init(cycle, worker); //??????????CPU??????

    ngx_setproctitle("worker process");

    /*
    ??ngx_worker_process_cycle?ßŸ??ßµ???????ngx_exiting??ngx_terminate??ngx_quit??ngx_reopen??4?????¶À????????????????
    */
    for ( ;; ) {

        if (ngx_exiting) {

            c = cycle->connections;

            for (i = 0; i < cycle->connection_n; i++) {

                /* THREAD: lock */

                if (c[i].fd != -1 && c[i].idle) {
                    c[i].close = 1;
                    c[i].read->handler(c[i].read);
                }
            }

            ngx_event_cancel_timers();

            if (ngx_event_timer_rbtree.root == ngx_event_timer_rbtree.sentinel)
            {
                ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, "exiting");

                ngx_worker_process_exit(cycle); 
            }
        }

        //ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle->log, 0, "worker(%P) cycle again", ngx_pid);

        ngx_process_events_and_timers(cycle);

        if (ngx_terminate) { //??ß€???????????ß’???????????????????????exit
            ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, "exiting");

            ngx_worker_process_exit(cycle);
        }

        if (ngx_quit) {
            ngx_quit = 0;
            ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0,
                          "gracefully shutting down");
            ngx_setproctitle("worker process is shutting down");

            if (!ngx_exiting) {
                ngx_close_listening_sockets(cycle);
          /*
                ???ngx_exiting?1???????????worker????????????????ngx_cycle_t?????????????????????????????????????????????
            ????????????ß÷?close???¶À???1?????????????????????????9???ß›????????Nginx??????????????ß›????????????????????
            ?????????????????ngx_event timer_ rbtree?????????????????????????????9???ß›?????????????????????????????
            ??????????????????????????ßµ?????ngx_process??events??and??timers???????????????????????????????????ß÷?????????????
            ??????????exit_process?????????????????????????worker?????
                ???ngx_exiting???¶À???¶∑???¶ƒ?????????????????????????QUIT????ngx_quit??ßµ???????????1??????ngx_exiting???1??
            */
                ngx_exiting = 1;//???quit????????????????????????if(ngx_exting)
            }
        }

       /*
         ???-s reopen?????????????????????????????????????????????????????????ßﬂ??ß“??????????????????????????????
         ????????????????????????????????????kill??????USR1???ßπ???????
        */
        if (ngx_reopen) {
            ngx_reopen = 0;
            ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, "reopening logs");
            ngx_reopen_files(cycle, -1);
        }
    }
}

/*
                                 |----------(ngx_worker_process_cycle->ngx_worker_process_init)
    ngx_start_worker_processes---| ngx_processes[]??????????????
                                 |----------ngx_pass_open_channel
*/
static void
ngx_worker_process_init(ngx_cycle_t *cycle, ngx_int_t worker)
{ //??????????CPU??????  ????epoll_crate??
    sigset_t          set;
    uint64_t          cpu_affinity;
    ngx_int_t         n;
    ngx_uint_t        i;
    struct rlimit     rlmt;
    ngx_core_conf_t  *ccf;
    ngx_listening_t  *ls;

    if (ngx_set_environment(cycle, NULL) == NULL) {
        /* fatal */
        exit(2);
    }

    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);

    if (worker >= 0 && ccf->priority != 0) { /*?????????*/
        if (setpriority(PRIO_PROCESS, 0, ccf->priority) == -1) {
            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                          "setpriority(%d) failed", ccf->priority);
        }
    }

    if (ccf->rlimit_nofile != NGX_CONF_UNSET) {
        rlmt.rlim_cur = (rlim_t) ccf->rlimit_nofile;
        rlmt.rlim_max = (rlim_t) ccf->rlimit_nofile;

        //RLIMIT_NOFILE??????????????????????????????????????????????EMFILE????
        if (setrlimit(RLIMIT_NOFILE, &rlmt) == -1) {
            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                          "setrlimit(RLIMIT_NOFILE, %i) failed",
                          ccf->rlimit_nofile);
        }
    }

    if (ccf->rlimit_core != NGX_CONF_UNSET) {
        rlmt.rlim_cur = (rlim_t) ccf->rlimit_core;
        rlmt.rlim_max = (rlim_t) ccf->rlimit_core;
        //???????????core???????????????(RLIMIT_CORE)???????????????????????????????????
        if (setrlimit(RLIMIT_CORE, &rlmt) == -1) {
            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                          "setrlimit(RLIMIT_CORE, %O) failed",
                          ccf->rlimit_core);
        }
        ngx_log_debugall(cycle->log, 0, "setrlimit(RLIMIT_CORE, &rlmt) OK,rlimit_core:%O",ccf->rlimit_core);
    }

    if (geteuid() == 0) {
        if (setgid(ccf->group) == -1) {
            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,
                          "setgid(%d) failed", ccf->group);
            /* fatal */
            exit(2);
        }

        if (initgroups(ccf->username, ccf->group) == -1) {
            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,
                          "initgroups(%s, %d) failed",
                          ccf->username, ccf->group);
        }

        if (setuid(ccf->user) == -1) {
            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,
                          "setuid(%d) failed", ccf->user);
            /* fatal */
            exit(2);
        }
    }

    if (worker >= 0) {
        cpu_affinity = ngx_get_cpu_affinity(worker);

        if (cpu_affinity) {
            ngx_setaffinity(cpu_affinity, cycle->log);
        }
    }

#if (NGX_HAVE_PR_SET_DUMPABLE)

    /* allow coredump after setuid() in Linux 2.4.x */

    if (prctl(PR_SET_DUMPABLE, 1, 0, 0, 0) == -1) {
        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                      "prctl(PR_SET_DUMPABLE) failed");
    }

#endif

    if (ccf->working_directory.len) { //°§??????????????????
        if (chdir((char *) ccf->working_directory.data) == -1) {
            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                          "chdir(\"%s\") failed", ccf->working_directory.data);
            /* fatal */
            exit(2);
        }
        ngx_log_debugall(cycle->log, 0, "chdir %V OK", &ccf->working_directory);
    }

    sigemptyset(&set);

    if (sigprocmask(SIG_SETMASK, &set, NULL) == -1) {
        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                      "sigprocmask() failed");
    }

    srandom((ngx_pid << 16) ^ ngx_time());

    /*
     * disable deleting previous events for the listening sockets because
     * in the worker processes there are no events at all at this point
     */
    ls = cycle->listening.elts;
    for (i = 0; i < cycle->listening.nelts; i++) {
        ls[i].previous = NULL;
    }

    for (i = 0; ngx_modules[i]; i++) {
        if (ngx_modules[i]->init_process) {
            if (ngx_modules[i]->init_process(cycle) == NGX_ERROR) { //ngx_event_process_init??
                /* fatal */
                exit(2);
            }
        }
    }

    /*
    
    ??socketpair????????sock[0]??sock[1]??????????????????????????????????????socket???????????close???????????sock[1]???????????
          int r = socketpair( AF_UNIX, SOCK_STREAM, 0, fd );
          if ( fork() ) {
              Parent process: echo client 
              int val = 0;
              close( fd[1] );          
               while ( 1 ) {
                sleep( 1 );
                ++val;
                printf( "Sending data: %d\n", val );
                write( fd[0], &val, sizeof(val) );
                read( fd[0], &val, sizeof(val) );
                printf( "Data received: %d\n", val );
              }
            }
            else {
               Child process: echo server 
              int val;
              close( fd[0] );
              while ( 1 ) {
                read( fd[1], &val, sizeof(val) );
                ++val;
                write( fd[1], &val, sizeof(val) );
              }
            }
          }
    ????????CSDN???????????????????http://blog.csdn.net/sunnyboychina/archive/2007/11/14/1884076.aspx 
    ------Solutions------
    ????socketpair??????????socket???????fork???????????????????socket?????????????????socket pair??????????????????????????????open????socket?? 
    ------Solutions------
    ???????????????????????????socketß’???????????ßÿ?????????ß’????????????????????????????????ß’???????????ß÷??????????? 
    ------Solutions------
    ß›ß›????????????????
    
    
    channel[0] ????????????????channel[1]????????????????????????????????????????????????????????????????????channel[0], 
    ???channel[1]; ??????????????????channel[0]?? ????ngx_channel???epoll?ßµ??????????ß÷???????????????????ngx_channel
    ??????????? channel[1]???????????????????????????????
    */
    //???????????????????? channel[1] ?? ????? channel[0]??????????????channel[1]?????????channel[0]???
    for (n = 0; n < ngx_last_process; n++) {

        if (ngx_processes[n].pid == -1) {
            continue;
        }

        if (n == ngx_process_slot) {
            continue;
        }

        if (ngx_processes[n].channel[1] == -1) {
            continue;
        }

        if (close(ngx_processes[n].channel[1]) == -1) { //??????????????????????ßﬂ???????
            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                          "close() channel failed");
        }
    }

    if (close(ngx_processes[ngx_process_slot].channel[0]) == -1) { //?????????ß’?? ??????????????????????
        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
                      "close() channel failed");
    }

#if 0
    ngx_last_process = 0;
#endif

    //????epoll add ??ngx_chanel ????epoll ??  
    if (ngx_add_channel_event(cycle, ngx_channel, NGX_READ_EVENT,
                              ngx_channel_handler) //??ngx_spawn_process?ß⁄??
        == NGX_ERROR)
    {
        /* fatal */
        exit(2);
    }
}


static void
ngx_worker_process_exit(ngx_cycle_t *cycle)
{
    ngx_uint_t         i;
    ngx_connection_t  *c;

    for (i = 0; ngx_modules[i]; i++) {
        if (ngx_modules[i]->exit_process) {
            ngx_modules[i]->exit_process(cycle);
        }
    }

    if (ngx_exiting) {
        c = cycle->connections;
        for (i = 0; i < cycle->connection_n; i++) {
            if (c[i].fd != -1
                && c[i].read
                && !c[i].read->accept
                && !c[i].read->channel
                && !c[i].read->resolver)
            {
                ngx_log_error(NGX_LOG_ALERT, cycle->log, 0,
                              "*%uA open socket #%d left in connection %ui",
                              c[i].number, c[i].fd, i);
                ngx_debug_quit = 1;
            }
        }

        if (ngx_debug_quit) {
            ngx_log_error(NGX_LOG_ALERT, cycle->log, 0, "aborting");
            ngx_debug_point();
        }
    }

    /*
     * Copy ngx_cycle->log related data to the special static exit cycle,
     * log, and log file structures enough to allow a signal handler to log.
     * The handler may be called when standard ngx_cycle->log allocated from
     * ngx_cycle->pool is already destroyed.
     */

    ngx_exit_log = *ngx_log_get_file_log(ngx_cycle->log);

    ngx_exit_log_file.fd = ngx_exit_log.file->fd;
    ngx_exit_log.file = &ngx_exit_log_file;
    ngx_exit_log.next = NULL;
    ngx_exit_log.writer = NULL;

    ngx_exit_cycle.log = &ngx_exit_log;
    ngx_exit_cycle.files = ngx_cycle->files;
    ngx_exit_cycle.files_n = ngx_cycle->files_n;
    ngx_cycle = &ngx_exit_cycle;

    ngx_destroy_pool(cycle->pool);

    ngx_log_error(NGX_LOG_NOTICE, ngx_cycle->log, 0, "exit");

    exit(0);
}

/*
???????????????¶ƒ???????????????????????????????ngx_channel_handler(ngx_event_t *ev)????????????ßµ?????mseeage??
????????????????????????????????????????????????? 
*/ //??ngx_write_channel???
static void
ngx_channel_handler(ngx_event_t *ev)
{
    ngx_int_t          n;
    ngx_channel_t      ch;
    ngx_connection_t  *c;

    if (ev->timedout) {
        ev->timedout = 0;
        return;
    }

    c = ev->data;

    ngx_log_debug0(NGX_LOG_DEBUG_CORE, ev->log, 0, "channel handler");

    for ( ;; ) {

        n = ngx_read_channel(c->fd, &ch, sizeof(ngx_channel_t), ev->log);

        ngx_log_debug1(NGX_LOG_DEBUG_CORE, ev->log, 0, "channel: %i", n);

        if (n == NGX_ERROR) {

            if (ngx_event_flags & NGX_USE_EPOLL_EVENT) {
                ngx_del_conn(c, 0);
            }

            ngx_close_connection(c);
            return;
        }

        if (ngx_event_flags & NGX_USE_EVENTPORT_EVENT) {
            char tmpbuf[256];
        
            snprintf(tmpbuf, sizeof(tmpbuf), "<%25s, %5d> epoll NGX_READ_EVENT(et) read add", NGX_FUNC_LINE);
            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ev->log, 0, tmpbuf);
            if (ngx_add_event(ev, NGX_READ_EVENT, 0) == NGX_ERROR) {
                return;
            }
        }

        if (n == NGX_AGAIN) {
            return;
        }

        ngx_log_debug1(NGX_LOG_DEBUG_CORE, ev->log, 0,
                       "channel command: %d", ch.command);

        switch (ch.command) {

        case NGX_CMD_QUIT:
            ngx_quit = 1;
            break;

        case NGX_CMD_TERMINATE:
            ngx_terminate = 1;
            break;

        case NGX_CMD_REOPEN:
            ngx_reopen = 1;
            break;

        case NGX_CMD_OPEN_CHANNEL:

            ngx_log_debug3(NGX_LOG_DEBUG_CORE, ev->log, 0,
                           "get channel s:%i pid:%P fd:%d",
                           ch.slot, ch.pid, ch.fd);

            //??ngx_processes??????????ß⁄????  
            ngx_processes[ch.slot].pid = ch.pid;
            ngx_processes[ch.slot].channel[0] = ch.fd;
            break;

        case NGX_CMD_CLOSE_CHANNEL:

            ngx_log_debug4(NGX_LOG_DEBUG_CORE, ev->log, 0,
                           "close channel s:%i pid:%P our:%P fd:%d",
                           ch.slot, ch.pid, ngx_processes[ch.slot].pid,
                           ngx_processes[ch.slot].channel[0]);

            if (close(ngx_processes[ch.slot].channel[0]) == -1) {
                ngx_log_error(NGX_LOG_ALERT, ev->log, ngx_errno,
                              "close() channel failed");
            }

            ngx_processes[ch.slot].channel[0] = -1;
            break;
        }
    }
}

/*
?????????????????nginx???????????varnish/squid??????????????????????????????Nginx????????????????????????nginx???????
????????????????????????cache?????’??????????????ó•??????????????????Nginx?????cache loader???????????????????
(cycle->pathes???????????)?????????ßµ???????????????????ß·?????proxy buffer???????proxy cache??

?1?????????????????????http?????no-store/no-cache/private/max-age=0????expires????????????????????????????nginx???ó±
*/ //????????????ngx_http_upstream_process_request->ngx_http_file_cache_update?ßﬂ??ß›???
static void  
ngx_cache_manager_process_cycle(ngx_cycle_t *cycle, void *data)
{ //nginx: cache loader process?????nginx: cache manager process??????ß⁄®≤???
    ngx_cache_manager_ctx_t *ctx = data;

    void         *ident[4];
    ngx_event_t   ev;

    /*
     * Set correct process type since closing listening Unix domain socket
     * in a master process also removes the Unix domain socket file.
     */
    ngx_process = NGX_PROCESS_HELPER;

    ngx_close_listening_sockets(cycle);

    /* Set a moderate number of connections for a helper process. */
    cycle->connection_n = 512;

    ngx_worker_process_init(cycle, -1);

    ngx_memzero(&ev, sizeof(ngx_event_t));
    ev.handler = ctx->handler; //ngx_cache_manager_process_handler  ngx_cache_loader_process_handler
    ev.data = ident;
    ev.log = cycle->log;
    ident[3] = (void *) -1;

    ngx_use_accept_mutex = 0;

    ngx_setproctitle(ctx->name);

    ngx_add_timer(&ev, ctx->delay, NGX_FUNC_LINE); //ctx->dealy?????ctx->handler;
    
    for ( ;; ) {

        if (ngx_terminate || ngx_quit) {
            ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, "exiting");
            exit(0);
        }

        if (ngx_reopen) {
            ngx_reopen = 0;
            ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, "reopening logs");
            ngx_reopen_files(cycle, -1);
        }

        ngx_process_events_and_timers(cycle);
    }
}

/*
??Nginx?ßµ??????????proxy(fastcgi) cache?????master process???????????????????????????????????(???????????????????)????????
????????????â^???????????????????¸v?ó®??????????????????????????????????????????????????????????
??????????(??Nginx?⁄Ö????????60??)??????????

???????????????????ngx_process_events_and_timers()?????ßµ??????ngx_event_expire_timers()??Nginx??ngx_event_timer_rbtree(?????)??
?ÀÆ????ß÷???????????????ß÷???????????????????????????????????????????????ß⁄?????????????????handler??????
?????handler?????ngx_cache_manager_process_handler??ngx_cache_loader_process_handler //????????????ngx_http_upstream_process_request->ngx_http_file_cache_update?ßﬂ??ß›???
*/

//???????????????????????°§???????manager()????????ngx_http_file_cache_manager()??????????????????????¸v????ßµ???
//????????????????ß€???????????????????????????????????????????????????
static void   //ngx_cache_manager_ctx
//cache manager ?????????????????????????????????? ?????????????¸v???????ß≥?????????????????????????????????????? ????? 
ngx_cache_manager_process_handler(ngx_event_t *ev)
{
    time_t        next, n;
    ngx_uint_t    i;
    ngx_path_t  **path;

    next = 60 * 60; //60S

    path = ngx_cycle->paths.elts;
    for (i = 0; i < ngx_cycle->paths.nelts; i++) { //???????ß÷?cache??
        //????manger???
        if (path[i]->manager) {
            n = path[i]->manager(path[i]->data);//manager ????????????????????????????????????????????????????
            //???????¶≈????????????????????n??next????ß≥?
            next = (n <= next) ? n : next; //????????????????????????ngx_add_timer?????????next????????????

            ngx_time_update();
        }
    }

    //cache manager ?????¸v???????ßπ???????? 1 ??ß≥????????????????®¥??? CPU?? cache manger ??????????? 1 ?? 
    if (next == 0) {
        next = 1;
    }

    ngx_add_timer(ev, next * 1000, NGX_FUNC_LINE); //??????ngx_cache_manager_process_handler->ngx_http_file_cache_manager
}

/*
??Nginx?ßµ??????????proxy(fastcgi) cache?????master process???????????????????????????????????(???????????????????)????????
????????????â^???????????????????¸v?ó®??????????????????????????????????????????????????????????
??????????(??Nginx?⁄Ö????????60??)??????????

Nginx ??????????????????????????????°§????????????????????????? ???????????????????? cache loader ??????®¿? 

??????? Nginx ????? cache manager ?????????????????????????????????? ?????????????¸v???????ß≥?????????????????????
????????????????? ????? 

???????????????????ngx_process_events_and_timers()?????ßµ??????ngx_event_expire_timers()??Nginx??ngx_event_timer_rbtree(?????)??
?ÀÆ????ß÷???????????????ß÷???????????????????????????????????????????????ß⁄?????????????????handler??????
?????handler?????ngx_cache_manager_process_handler??ngx_cache_loader_process_handler 
//????????????ngx_http_upstream_process_request->ngx_http_file_cache_update?ßﬂ??ß›???
*/
static void //ngx_cache_loader_ctx
ngx_cache_loader_process_handler(ngx_event_t *ev) //??????????????°§????????????????????????? ?????????
{//ngx_cache_manager_process_cycle????ßµ?????????60s????????®≤??????????ngx_cache_manager_process_cycle????60s???????????????ß⁄®≤???
    ngx_uint_t     i;
    ngx_path_t   **path;
    ngx_cycle_t   *cycle;

    cycle = (ngx_cycle_t *) ngx_cycle;

    path = cycle->paths.elts;
    for (i = 0; i < cycle->paths.nelts; i++) {

        if (ngx_terminate || ngx_quit) {
            break;
        }

        if (path[i]->loader) {
            path[i]->loader(path[i]->data); //ngx_http_file_cache_loader
            ngx_time_update();
        }
    }

    exit(0);
}
